% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/from_df.R
\name{rd_gd_from_df}
\alias{rd_gd_from_df}
\alias{to_RowData_from_df}
\alias{to_GridData_from_df}
\title{Create RowData or GridData objects out of \code{data.frame}}
\usage{
to_RowData_from_df(
  df,
  names_format = NULL,
  values_format = NULL,
  names_types = NULL,
  values_types = NULL,
  transpose = FALSE
)

to_GridData_from_df(
  df,
  startRow,
  startColumn,
  names_format = NULL,
  values_format = NULL,
  names_types = NULL,
  values_types = NULL,
  transpose = FALSE
)
}
\arguments{
\item{df}{\code{data.frame} object to use the data from}

\item{names_format, values_format}{object of class \link{CellFormat} that provides
format for column names and values}

\item{names_types, values_types}{vector of types to use for column names and
values. If nothing is provided, types are guessed for \code{value_types} (\code{names_types})
are always presumed to be of \code{c} type. For more info read \emph{details} section}

\item{transpose}{if \code{TRUE}, then the data.frame will be transposed, so the first
column in Sheets will be the names, and every next column: one row from the \code{df}}

\item{startRow, startColumn}{zero-based indices of first row and column
this \code{GridData} refers to}
}
\description{
Higher-level wrapper for mass \link{RowData} creation, taking as input
data in form of \code{data.frame}.
}
\details{
\subsection{Set types}{

\code{names_types} and \code{values_types} could be provided as singular value, in which
case ALL names and ALL columns will be saved as the same class, or as a vector
of the same length as number of columns, in which case the every column will
have its own class provided.

Possible types are:
\itemize{
\item \code{n} for values formatted as numeric
\item \code{c} for values formatted as character
\item \code{b} for values formatted as boolean (logical)
\item \code{f} if values are characters that need to be interpreted as googlesheets
formulas. This type is never guessed
\item \code{d} for values to be formatted as \code{DATE} numeric type. If they aren't
\code{deepgsh_serial_number}, they will be coerced first
\item \code{dt} for values to be formatted as \code{DATE_TIME} numeric type. If they aren't
\code{deepgsh_serial_number}, they will be coerced first
}

If \code{values_types} argument is kept as \code{NULL}, the types will be interpreted
from data.frame column type.
}

\subsection{Type guess}{

If \code{values_types} aren't provided, they will be guessed
automatically. Guessing is done on basis of vector type in following order:
\enumerate{
\item \code{logical} vectors will be given \code{b} type (entered as \emph{boolValue})
\item \code{numeric} vectors will be given \code{n} type (entered as \emph{numberValue})
\item \code{factor} vectors will be given \code{c} type (entered as \emph{stringValue})
\item vectors will be tested if they can be processed with \code{lubridate::as_date_time()}
or if they consists of \link{deepgs_serial_number}.
4a. First 20 values will be tested if they are dates or NAs. If so,
they will be given \code{d} type (entered as \emph{numberValue} with \code{DATE} \link{NumberFormat})
4b. If not, they will be given \code{dt} type (entered as \emph{numberValue} with
\code{DATE_TIME} \link{NumberFormat})
\item If none of above applies, they will be given \code{c} type.
}
}
}
